#
# Autogenerated by Frugal Compiler (3.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



import asyncio
from datetime import timedelta
import inspect

from frugal.aio.processor import FBaseProcessor
from frugal.aio.processor import FProcessorFunction
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.middleware import Method
from frugal.transport import TMemoryOutputBuffer
from frugal.util.deprecate import deprecated
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException
from .ttypes import *


class Iface(object):

    async def updatePassword(self, ctx, authSessionId, request):
        """
        Args:
            ctx: FContext
            authSessionId: string
            request: IdentityCredentialRequest
        """
        pass

    async def getAuthRSAKey(self, ctx, authSessionId, identityProvider):
        """
        Args:
            ctx: FContext
            authSessionId: string
            identityProvider: IdentityProvider
        """
        pass

    async def openAuthSession(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: AuthSessionRequest
        """
        pass

    async def normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        """
        Args:
            ctx: FContext
            countryCode: string
            phoneNumber: string
            countryCodeHint: string
        """
        pass

    async def respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        """
        Args:
            ctx: FContext
            verifier: string
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
            errorCode: ErrorCode
        """
        pass

    async def confirmE2EELogin(self, ctx, verifier, deviceSecret):
        """
        Args:
            ctx: FContext
            verifier: string
            deviceSecret: binary string
        """
        pass

    async def logoutZ(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def loginZ(self, ctx, loginRequest):
        """
        Args:
            ctx: FContext
            loginRequest: LoginRequest
        """
        pass

    async def issueTokenForAccountMigrationSettings(self, ctx, enforce):
        """
        Args:
            ctx: FContext
            enforce: boolean
        """
        pass

    async def issueTokenForAccountMigration(self, ctx, migrationSessionId):
        """
        Args:
            ctx: FContext
            migrationSessionId: string
        """
        pass

    async def verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
            errorCode: ErrorCode
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        middleware += provider.get_middleware()
        self._methods = {
            'updatePassword': Method(self._updatePassword, middleware),
            'getAuthRSAKey': Method(self._getAuthRSAKey, middleware),
            'openAuthSession': Method(self._openAuthSession, middleware),
            'normalizePhoneNumber': Method(self._normalizePhoneNumber, middleware),
            'respondE2EELoginRequest': Method(self._respondE2EELoginRequest, middleware),
            'confirmE2EELogin': Method(self._confirmE2EELogin, middleware),
            'logoutZ': Method(self._logoutZ, middleware),
            'loginZ': Method(self._loginZ, middleware),
            'issueTokenForAccountMigrationSettings': Method(self._issueTokenForAccountMigrationSettings, middleware),
            'issueTokenForAccountMigration': Method(self._issueTokenForAccountMigration, middleware),
            'verifyQrcodeWithE2EE': Method(self._verifyQrcodeWithE2EE, middleware),
        }

    async def updatePassword(self, ctx, authSessionId, request):
        """
        Args:
            ctx: FContext
            authSessionId: string
            request: IdentityCredentialRequest
        """
        return await self._methods['updatePassword']([ctx, authSessionId, request])

    async def _updatePassword(self, ctx, authSessionId, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('updatePassword', TMessageType.CALL, 0)
        args = updatePassword_args()
        args.authSessionId = authSessionId
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updatePassword_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "updatePassword failed: unknown result")

    async def getAuthRSAKey(self, ctx, authSessionId, identityProvider):
        """
        Args:
            ctx: FContext
            authSessionId: string
            identityProvider: IdentityProvider
        """
        return await self._methods['getAuthRSAKey']([ctx, authSessionId, identityProvider])

    async def _getAuthRSAKey(self, ctx, authSessionId, identityProvider):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getAuthRSAKey', TMessageType.CALL, 0)
        args = getAuthRSAKey_args()
        args.authSessionId = authSessionId
        args.identityProvider = identityProvider
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getAuthRSAKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getAuthRSAKey failed: unknown result")

    async def openAuthSession(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: AuthSessionRequest
        """
        return await self._methods['openAuthSession']([ctx, request])

    async def _openAuthSession(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('openAuthSession', TMessageType.CALL, 0)
        args = openAuthSession_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = openAuthSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "openAuthSession failed: unknown result")

    async def normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        """
        Args:
            ctx: FContext
            countryCode: string
            phoneNumber: string
            countryCodeHint: string
        """
        return await self._methods['normalizePhoneNumber']([ctx, countryCode, phoneNumber, countryCodeHint])

    async def _normalizePhoneNumber(self, ctx, countryCode, phoneNumber, countryCodeHint):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('normalizePhoneNumber', TMessageType.CALL, 0)
        args = normalizePhoneNumber_args()
        args.countryCode = countryCode
        args.phoneNumber = phoneNumber
        args.countryCodeHint = countryCodeHint
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = normalizePhoneNumber_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "normalizePhoneNumber failed: unknown result")

    async def respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        """
        Args:
            ctx: FContext
            verifier: string
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
            errorCode: ErrorCode
        """
        return await self._methods['respondE2EELoginRequest']([ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode])

    async def _respondE2EELoginRequest(self, ctx, verifier, publicKey, encryptedKeyChain, hashKeyChain, errorCode):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('respondE2EELoginRequest', TMessageType.CALL, 0)
        args = respondE2EELoginRequest_args()
        args.verifier = verifier
        args.publicKey = publicKey
        args.encryptedKeyChain = encryptedKeyChain
        args.hashKeyChain = hashKeyChain
        args.errorCode = errorCode
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = respondE2EELoginRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
    async def confirmE2EELogin(self, ctx, verifier, deviceSecret):
        """
        Args:
            ctx: FContext
            verifier: string
            deviceSecret: binary string
        """
        return await self._methods['confirmE2EELogin']([ctx, verifier, deviceSecret])

    async def _confirmE2EELogin(self, ctx, verifier, deviceSecret):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('confirmE2EELogin', TMessageType.CALL, 0)
        args = confirmE2EELogin_args()
        args.verifier = verifier
        args.deviceSecret = deviceSecret
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = confirmE2EELogin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "confirmE2EELogin failed: unknown result")

    async def logoutZ(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return await self._methods['logoutZ']([ctx])

    async def _logoutZ(self, ctx):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('logoutZ', TMessageType.CALL, 0)
        args = logoutZ_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = logoutZ_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
    async def loginZ(self, ctx, loginRequest):
        """
        Args:
            ctx: FContext
            loginRequest: LoginRequest
        """
        return await self._methods['loginZ']([ctx, loginRequest])

    async def _loginZ(self, ctx, loginRequest):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('loginZ', TMessageType.CALL, 0)
        args = loginZ_args()
        args.loginRequest = loginRequest
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = loginZ_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "loginZ failed: unknown result")

    async def issueTokenForAccountMigrationSettings(self, ctx, enforce):
        """
        Args:
            ctx: FContext
            enforce: boolean
        """
        return await self._methods['issueTokenForAccountMigrationSettings']([ctx, enforce])

    async def _issueTokenForAccountMigrationSettings(self, ctx, enforce):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('issueTokenForAccountMigrationSettings', TMessageType.CALL, 0)
        args = issueTokenForAccountMigrationSettings_args()
        args.enforce = enforce
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = issueTokenForAccountMigrationSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "issueTokenForAccountMigrationSettings failed: unknown result")

    async def issueTokenForAccountMigration(self, ctx, migrationSessionId):
        """
        Args:
            ctx: FContext
            migrationSessionId: string
        """
        return await self._methods['issueTokenForAccountMigration']([ctx, migrationSessionId])

    async def _issueTokenForAccountMigration(self, ctx, migrationSessionId):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('issueTokenForAccountMigration', TMessageType.CALL, 0)
        args = issueTokenForAccountMigration_args()
        args.migrationSessionId = migrationSessionId
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = issueTokenForAccountMigration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "issueTokenForAccountMigration failed: unknown result")

    async def verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        """
        Args:
            ctx: FContext
            verifier: string
            pinCode: string
            errorCode: ErrorCode
            publicKey: E2EEPublicKey
            encryptedKeyChain: binary string
            hashKeyChain: binary string
        """
        return await self._methods['verifyQrcodeWithE2EE']([ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain])

    async def _verifyQrcodeWithE2EE(self, ctx, verifier, pinCode, errorCode, publicKey, encryptedKeyChain, hashKeyChain):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('verifyQrcodeWithE2EE', TMessageType.CALL, 0)
        args = verifyQrcodeWithE2EE_args()
        args.verifier = verifier
        args.pinCode = pinCode
        args.errorCode = errorCode
        args.publicKey = publicKey
        args.encryptedKeyChain = encryptedKeyChain
        args.hashKeyChain = hashKeyChain
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = verifyQrcodeWithE2EE_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "verifyQrcodeWithE2EE failed: unknown result")


class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('updatePassword', _updatePassword(Method(handler.updatePassword, middleware), self.get_write_lock()))
        self.add_to_processor_map('getAuthRSAKey', _getAuthRSAKey(Method(handler.getAuthRSAKey, middleware), self.get_write_lock()))
        self.add_to_processor_map('openAuthSession', _openAuthSession(Method(handler.openAuthSession, middleware), self.get_write_lock()))
        self.add_to_processor_map('normalizePhoneNumber', _normalizePhoneNumber(Method(handler.normalizePhoneNumber, middleware), self.get_write_lock()))
        self.add_to_processor_map('respondE2EELoginRequest', _respondE2EELoginRequest(Method(handler.respondE2EELoginRequest, middleware), self.get_write_lock()))
        self.add_to_processor_map('confirmE2EELogin', _confirmE2EELogin(Method(handler.confirmE2EELogin, middleware), self.get_write_lock()))
        self.add_to_processor_map('logoutZ', _logoutZ(Method(handler.logoutZ, middleware), self.get_write_lock()))
        self.add_to_processor_map('loginZ', _loginZ(Method(handler.loginZ, middleware), self.get_write_lock()))
        self.add_to_processor_map('issueTokenForAccountMigrationSettings', _issueTokenForAccountMigrationSettings(Method(handler.issueTokenForAccountMigrationSettings, middleware), self.get_write_lock()))
        self.add_to_processor_map('issueTokenForAccountMigration', _issueTokenForAccountMigration(Method(handler.issueTokenForAccountMigration, middleware), self.get_write_lock()))
        self.add_to_processor_map('verifyQrcodeWithE2EE', _verifyQrcodeWithE2EE(Method(handler.verifyQrcodeWithE2EE, middleware), self.get_write_lock()))


class _updatePassword(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updatePassword, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = updatePassword_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updatePassword_result()
        try:
            ret = self._handler([ctx, args.authSessionId, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "updatePassword", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "updatePassword", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updatePassword', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updatePassword", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getAuthRSAKey(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getAuthRSAKey, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = getAuthRSAKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAuthRSAKey_result()
        try:
            ret = self._handler([ctx, args.authSessionId, args.identityProvider])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getAuthRSAKey", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getAuthRSAKey", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getAuthRSAKey', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getAuthRSAKey", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _openAuthSession(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_openAuthSession, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = openAuthSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openAuthSession_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "openAuthSession", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "openAuthSession", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('openAuthSession', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "openAuthSession", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _normalizePhoneNumber(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_normalizePhoneNumber, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = normalizePhoneNumber_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = normalizePhoneNumber_result()
        try:
            ret = self._handler([ctx, args.countryCode, args.phoneNumber, args.countryCodeHint])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "normalizePhoneNumber", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "normalizePhoneNumber", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('normalizePhoneNumber', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "normalizePhoneNumber", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _respondE2EELoginRequest(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_respondE2EELoginRequest, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = respondE2EELoginRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = respondE2EELoginRequest_result()
        try:
            ret = self._handler([ctx, args.verifier, args.publicKey, args.encryptedKeyChain, args.hashKeyChain, args.errorCode])
            if inspect.iscoroutine(ret):
                ret = await ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "respondE2EELoginRequest", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "respondE2EELoginRequest", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('respondE2EELoginRequest', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "respondE2EELoginRequest", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _confirmE2EELogin(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_confirmE2EELogin, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = confirmE2EELogin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = confirmE2EELogin_result()
        try:
            ret = self._handler([ctx, args.verifier, args.deviceSecret])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "confirmE2EELogin", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "confirmE2EELogin", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('confirmE2EELogin', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "confirmE2EELogin", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _logoutZ(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_logoutZ, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = logoutZ_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logoutZ_result()
        try:
            ret = self._handler([ctx])
            if inspect.iscoroutine(ret):
                ret = await ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "logoutZ", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "logoutZ", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('logoutZ', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "logoutZ", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _loginZ(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_loginZ, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = loginZ_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loginZ_result()
        try:
            ret = self._handler([ctx, args.loginRequest])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "loginZ", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "loginZ", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('loginZ', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "loginZ", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _issueTokenForAccountMigrationSettings(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_issueTokenForAccountMigrationSettings, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = issueTokenForAccountMigrationSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueTokenForAccountMigrationSettings_result()
        try:
            ret = self._handler([ctx, args.enforce])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('issueTokenForAccountMigrationSettings', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "issueTokenForAccountMigrationSettings", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _issueTokenForAccountMigration(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_issueTokenForAccountMigration, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = issueTokenForAccountMigration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueTokenForAccountMigration_result()
        try:
            ret = self._handler([ctx, args.migrationSessionId])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('issueTokenForAccountMigration', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "issueTokenForAccountMigration", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _verifyQrcodeWithE2EE(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_verifyQrcodeWithE2EE, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = verifyQrcodeWithE2EE_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyQrcodeWithE2EE_result()
        try:
            ret = self._handler([ctx, args.verifier, args.pinCode, args.errorCode, args.publicKey, args.encryptedKeyChain, args.hashKeyChain])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('verifyQrcodeWithE2EE', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "verifyQrcodeWithE2EE", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class updatePassword_args(object):
    """
    Attributes:
     - authSessionId
     - request
    """
    def __init__(self, authSessionId=None, request=None):
        self.authSessionId = authSessionId
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.authSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.request = IdentityCredentialRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updatePassword_args')
        if self.authSessionId is not None:
            oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
            oprot.writeString(self.authSessionId)
            oprot.writeFieldEnd()
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 3)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.authSessionId))
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updatePassword_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IdentityCredentialResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updatePassword_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAuthRSAKey_args(object):
    """
    Attributes:
     - authSessionId
     - identityProvider
    """
    def __init__(self, authSessionId=None, identityProvider=None):
        self.authSessionId = authSessionId
        self.identityProvider = identityProvider

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.authSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.identityProvider = IdentityProvider(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAuthRSAKey_args')
        if self.authSessionId is not None:
            oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
            oprot.writeString(self.authSessionId)
            oprot.writeFieldEnd()
        if self.identityProvider is not None:
            oprot.writeFieldBegin('identityProvider', TType.I32, 3)
            oprot.writeI32(self.identityProvider)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.authSessionId))
        value = (value * 31) ^ hash(make_hashable(self.identityProvider))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getAuthRSAKey_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RSAKey()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getAuthRSAKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class openAuthSession_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = AuthSessionRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('openAuthSession_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class openAuthSession_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('openAuthSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class normalizePhoneNumber_args(object):
    """
    Attributes:
     - countryCode
     - phoneNumber
     - countryCodeHint
    """
    def __init__(self, countryCode=None, phoneNumber=None, countryCodeHint=None):
        self.countryCode = countryCode
        self.phoneNumber = phoneNumber
        self.countryCodeHint = countryCodeHint

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.countryCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.phoneNumber = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.countryCodeHint = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('normalizePhoneNumber_args')
        if self.countryCode is not None:
            oprot.writeFieldBegin('countryCode', TType.STRING, 2)
            oprot.writeString(self.countryCode)
            oprot.writeFieldEnd()
        if self.phoneNumber is not None:
            oprot.writeFieldBegin('phoneNumber', TType.STRING, 3)
            oprot.writeString(self.phoneNumber)
            oprot.writeFieldEnd()
        if self.countryCodeHint is not None:
            oprot.writeFieldBegin('countryCodeHint', TType.STRING, 4)
            oprot.writeString(self.countryCodeHint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.countryCode))
        value = (value * 31) ^ hash(make_hashable(self.phoneNumber))
        value = (value * 31) ^ hash(make_hashable(self.countryCodeHint))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class normalizePhoneNumber_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('normalizePhoneNumber_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondE2EELoginRequest_args(object):
    """
    Attributes:
     - verifier
     - publicKey
     - encryptedKeyChain
     - hashKeyChain
     - errorCode
    """
    def __init__(self, verifier=None, publicKey=None, encryptedKeyChain=None, hashKeyChain=None, errorCode=None):
        self.verifier = verifier
        self.publicKey = publicKey
        self.encryptedKeyChain = encryptedKeyChain
        self.hashKeyChain = hashKeyChain
        self.errorCode = errorCode

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.encryptedKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.hashKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.errorCode = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondE2EELoginRequest_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 1)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 2)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        if self.encryptedKeyChain is not None:
            oprot.writeFieldBegin('encryptedKeyChain', TType.STRING, 3)
            oprot.writeBinary(self.encryptedKeyChain)
            oprot.writeFieldEnd()
        if self.hashKeyChain is not None:
            oprot.writeFieldBegin('hashKeyChain', TType.STRING, 4)
            oprot.writeBinary(self.hashKeyChain)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 5)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.encryptedKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.hashKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.errorCode))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class respondE2EELoginRequest_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('respondE2EELoginRequest_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmE2EELogin_args(object):
    """
    Attributes:
     - verifier
     - deviceSecret
    """
    def __init__(self, verifier=None, deviceSecret=None):
        self.verifier = verifier
        self.deviceSecret = deviceSecret

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.deviceSecret = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmE2EELogin_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 1)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.deviceSecret is not None:
            oprot.writeFieldBegin('deviceSecret', TType.STRING, 2)
            oprot.writeBinary(self.deviceSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.deviceSecret))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class confirmE2EELogin_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('confirmE2EELogin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutZ_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutZ_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class logoutZ_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('logoutZ_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginZ_args(object):
    """
    Attributes:
     - loginRequest
    """
    def __init__(self, loginRequest=None):
        self.loginRequest = loginRequest

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.loginRequest = LoginRequest()
                    self.loginRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginZ_args')
        if self.loginRequest is not None:
            oprot.writeFieldBegin('loginRequest', TType.STRUCT, 2)
            self.loginRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.loginRequest))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class loginZ_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoginResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('loginZ_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigrationSettings_args(object):
    """
    Attributes:
     - enforce
    """
    def __init__(self, enforce=None):
        self.enforce = enforce

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.BOOL:
                    self.enforce = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigrationSettings_args')
        if self.enforce is not None:
            oprot.writeFieldBegin('enforce', TType.BOOL, 2)
            oprot.writeBool(self.enforce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.enforce))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigrationSettings_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SecurityCenterResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigrationSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigration_args(object):
    """
    Attributes:
     - migrationSessionId
    """
    def __init__(self, migrationSessionId=None):
        self.migrationSessionId = migrationSessionId

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.migrationSessionId = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigration_args')
        if self.migrationSessionId is not None:
            oprot.writeFieldBegin('migrationSessionId', TType.STRING, 2)
            oprot.writeString(self.migrationSessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.migrationSessionId))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class issueTokenForAccountMigration_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SecurityCenterResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('issueTokenForAccountMigration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcodeWithE2EE_args(object):
    """
    Attributes:
     - verifier
     - pinCode
     - errorCode
     - publicKey
     - encryptedKeyChain
     - hashKeyChain
    """
    def __init__(self, verifier=None, pinCode=None, errorCode=None, publicKey=None, encryptedKeyChain=None, hashKeyChain=None):
        self.verifier = verifier
        self.pinCode = pinCode
        self.errorCode = errorCode
        self.publicKey = publicKey
        self.encryptedKeyChain = encryptedKeyChain
        self.hashKeyChain = hashKeyChain

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.verifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pinCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.errorCode = ErrorCode(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.publicKey = E2EEPublicKey()
                    self.publicKey.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.encryptedKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.hashKeyChain = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcodeWithE2EE_args')
        if self.verifier is not None:
            oprot.writeFieldBegin('verifier', TType.STRING, 2)
            oprot.writeString(self.verifier)
            oprot.writeFieldEnd()
        if self.pinCode is not None:
            oprot.writeFieldBegin('pinCode', TType.STRING, 3)
            oprot.writeString(self.pinCode)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 4)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.publicKey is not None:
            oprot.writeFieldBegin('publicKey', TType.STRUCT, 5)
            self.publicKey.write(oprot)
            oprot.writeFieldEnd()
        if self.encryptedKeyChain is not None:
            oprot.writeFieldBegin('encryptedKeyChain', TType.STRING, 6)
            oprot.writeBinary(self.encryptedKeyChain)
            oprot.writeFieldEnd()
        if self.hashKeyChain is not None:
            oprot.writeFieldBegin('hashKeyChain', TType.STRING, 7)
            oprot.writeBinary(self.hashKeyChain)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.verifier))
        value = (value * 31) ^ hash(make_hashable(self.pinCode))
        value = (value * 31) ^ hash(make_hashable(self.errorCode))
        value = (value * 31) ^ hash(make_hashable(self.publicKey))
        value = (value * 31) ^ hash(make_hashable(self.encryptedKeyChain))
        value = (value * 31) ^ hash(make_hashable(self.hashKeyChain))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class verifyQrcodeWithE2EE_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('verifyQrcodeWithE2EE_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

